use std::env;
use std::ffi::OsString;
use std::fs::File;
use std::io::{Write, Result, Error, ErrorKind};
use std::path::Path;

use crate::{NAME, VERSION};
use crate::generator::{Codegen, Block};

use dbml_rs::*;
use inflector::Inflector;

mod traits;
use traits::*;
mod err;
mod config;

/// Protobuf target version.
#[derive(Debug, PartialEq, Clone)]
pub enum Target {
  // Proto2,
  Proto3
}

/// Configuration options for the code generation.
#[derive(Debug, PartialEq, Clone)]
pub struct Config  {
  /// Input file path.
  in_path: OsString,
  /// Output file path (optional). The default output path is `OUT_DIR`.
  out_path: Option<OsString>,
  /// Protobuf target version.
  target: Target
}

impl Config {
  pub fn new(in_path: impl AsRef<Path>, target: Target) -> Self {
    Self {
      in_path: in_path.as_ref().into(),
      out_path: None,
      target
    }
  }

  pub fn set_out_path(mut self, path: impl AsRef<Path>) -> Self {
    self.out_path = Some(path.as_ref().into());

    self
  }

  pub fn transpile(&self) -> Result<()> {
    let sem_ast = dbml_rs::parse_file(&self.in_path).unwrap_or_else(|e| panic!("{}", e));
    
    let result = transpile(sem_ast, &self.target).unwrap_or_else(|e| panic!("{}", e));

    let out_path = match self.out_path.clone() {
      Some(out_path) => out_path,
      None => {
        env::var_os("OUT_DIR")
        .ok_or_else(|| {
          Error::new(ErrorKind::Other, "OUT_DIR environment variable is not set")
        })?
      }
    };

    File::create(out_path)?.write_all(result.as_bytes())?;

    Ok(())
  }
}

fn transpile(ast: analyzer::SemanticSchemaBlock, target: &Target) -> Result<String> {
  let codegen = Codegen::new()
    .line(format!("//! Generated by {NAME} {VERSION}"))
    .line_skip(1)
    .line(r#"syntax = "proto3";"#)
    .line_skip(1)
    .line(r#"import "google/protobuf/timestamp.proto";"#);

  let codegen = ast.tables.iter().fold(codegen, |acc, table| {
    let ast::table::TableBlock {
      ident,
      cols: fields,
      indexes,
      ..
    } = table.clone();

    let table_block = Block::new(1, Some(format!("message {}", ident.name.to_pascal_case())));

    // field listing
    let table_block = fields.into_iter().enumerate().fold(table_block,|acc, (i, field)| {
      let mut out_fields = vec![];
      
      if field.settings.is_nullable {
        out_fields.push(format!("optional"))
      }
      if let Some(exp_type) = field.r#type.to_col_type() {
        out_fields.push(format!("{}", exp_type))
      }
      else {
        panic!("unsupported type")
      }

      out_fields.push(field.name);
      
      acc
        .line(format!("{} = {};", out_fields.join(" "), i + 1))
    });

    acc
      .line_skip(1)
      .block(table_block)
  });

  let codegen = ast.enums.into_iter().fold(codegen, |acc, r#enum| {
    let ast::enums::EnumBlock {
      ident: ast::enums::EnumIdent {
        name,
        schema,
      },
      values,
    } = r#enum;

    let enum_block = Block::new(1, Some(format!("enum {}", name.to_pascal_case())));

    let enum_block = values.into_iter().enumerate().fold(enum_block,|acc, (i, value)| {
      let value_name = value.value;

      acc
        .line(format!("{} = {};", value_name.to_snake_case().to_uppercase(), i))
    });

    acc
      .line_skip(1)
      .block(enum_block)
  });

  Ok(codegen.to_string())
}
